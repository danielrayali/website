<!DOCTYPE html>
<html lang="en-US">

  <head>
    <title>Daniel Ali</title>
    <meta charset="UTF-8">
    <style>
      h1 {
        display:block;
        font-size: 2em;
        margin-block-start: 0.67em;
        margin-block-end: 0.67em;
        margin-inline-start: 0px;
        margin-inline-end: 0px;
        font-weight: bold;
        margin-bottom: 0px
      }
      h3 {
        display: block;
        font-size: 1.17em;
        font-style: normal;
        margin-block-start: 1em;
        margin-block-end: 1em;
        margin-inline-start: 0px;
        margin-inline-end: 0px;
        font-weight: bold;
        margin-bottom: 0px
      }
      pre {
        background-color: #edf5e1;
        font-family: 'Courier New', Courier, monospace;
        color: #0d1432;
        padding: 10px;
      }
      pre.inline {
        background-color: unset;
        padding: unset;
      }
      p {
        text-align: left;
        line-height: 1.6;
      }
      body {
        width:50%;
        margin:auto;
        /*background-color: #eee2dc;*/
      }
      .subhead {
        font-style:italic;
        padding-top:2px;
        margin-top:0px;
        font-size:small;
      }
      .caption {
        font-style:italic;
        padding-top:2px;
        margin-top:0px;
        font-size:small;
        margin-left: auto;
        margin-right: auto;
        width: 50%;
      }
      /* Create two equal columns that floats next to each other */
      .column {
        width: 50%;
      }
      .left {
        float: left;
      }
      .right {
        float: right;
        height: 78.44px;  /* This is probably not the right way to do this */
        margin-bottom: 0px;
      }
      #right-content {
        margin-top: 55px;
        margin-bottom: 0px;
        float: right;
      }
      /* Clear floats after the columns */
      .row:after {
        content: "";
        display: table;
        clear: both;
      }
      .center {
        display: block;
        margin-left: auto;
        margin-right: auto;
        width: 50%;
      }
    </style>
  </head>

  <body style="font-family: Verdana,sans-serif;">
  <header>
    <div class="row">
      <div class="column left">
        <h1>Daniel Ali</h1>
        <div class="subhead">On software and things</div>
      </div>
      <div class="column right">
        <p id="right-content"><a href="articles.html">articles</a> <a href="index.html">about me</a></p>
      </div>
    </div>
  </header>

  <head>
  <script data-ad-client="ca-pub-9753669098416615" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </head>

  <hr>

  <h3>How To Build Complex Software</h3>
  <div class="subhead">2021-06-01</div>

  <p>
    Don't build complex software. Instead, build small simple units of software. Test those units. Use those units. What features are missing from those units? Expand the unit or create a new unit of software?
  </p>

  <p>
    This is all subjective and will vary from project to project, but also from person to person. Even two different people solving the exact same problem may not agree where one unit of software should end and another should begin.
  </p>

  <p>
    The goal is to figure out these boundaries for yourself and what works and what doesn't work. It's not easy to get right. Well-written software is somewhat of an art. That said, the overarching goal is simple and can be applied to any situation. Don't build something complex, build something simple.
  </p>

  <h3>Solve Problems</h3>
  <div class="subhead">2020-12-23</div>

  <p>
    I recently read Brandon Smith's blog post about a quote from author Michael Pollen. It rewrote the quote "Eat food. Not too much. Mostly plants" to "Write code. Not too much. Mostly functions." This makes good points in a simple form, something I believe is difficult to do. While these are good points, I thought of a different re-write I would apply to the larger discipline of software engineering. One that would be more in the context of a problem solving domain, rather than specifically associated with writing code.
  </p>

  <p style="text-align:center">
      <i>"Solve problems. Not too deep. Mostly plans."</i>
  </p>

  <p>
    I have long held the belief that "engineer" is a fancy way to say "problem solver". Each discipline of engineering, software, hardware, mechanical, electrical, etc. is just more familiar with a different set of problems, solutions and techniques. I think it's fair to say code is a tool that software engineers use to solve problems. Sometimes its carefully selecting the right functional language to express a neural net to solve a physics problem. Sometimes its opening Excel to solve a budget issue. I believe "Solve problems" is the essence of both situations. As a software engineer, one of those problems is probably more attractive than the other.
  </p>

  <p>
    There has been lots of discussion on the 80% solution. "Not too deep" represents this strategy. Avoid diminishing returns by identifying your low cost 80% solution. Provide as much value as quickly as you can. This is a difficult balance to achieve, but worth the investment. Of course, if your customer pays for a 100% solution, you should probably implement the other 20% at some point.
  </p>

  <p>
    "Mostly plans" is my favorite because it represents a very large and very important area that is easily forgotten in the problem solving domain. Here is that point in the blog post where I mention that software engineering is 80% reading and 20% writing code. Implementing the wrong solution is 100% worse than slowly implementing the right solution. Measure twice, cut once, etc, etc. Think more about the problem you are trying to solve in context of the larger picture. Think about the solution you are using in the context of the larger picture.
  </p>

  <p>
    If the customer pays for the wrong solution, do what you can to convince them they need the right one. But, at the end of the day always solve the very practical problem of generating an income.
  </p>

  <h3>Work Doesn't Have to be Stressful</h3>
  <div class="subhead">2020-09-17</div>

  <p>
    As a software engineer, certain tasks require more time than expected. This is usually thought of as a Bad Thing™. Anxiety increases as expectation and reality diverge. Developers rush and quality suffers.
  </p>

  <p>
    When this happens to me, I become tunnel visioned on completing the task. I lose sight of context. I under-think my planning and overdo my actions. My work/life balance suffers.
  </p>

  <p>
    It is difficult for me to be aware of when this is happening, as it is happening. I convince myself efficiency is king and to drop non-essentials. Things like planning and documentation. This is made worse by the fact that my group thrives off of small budgets and rapid development. At one point "Rapid Solutions" was our division name.
  </p>

  <p>
    In order to avoid this, I need something to remind myself to step back and check in. I don't have anything like a timer or mood ring to tell me when I'm stressed, so I merly attempt to mentally check-in each time I feel stressed.
  </p>

  <p>
    When I check-in, I try to evaluate where this stress is coming from. Its almost always due to the amount of things I have to do, rather than one specific event or task. It isn't usually a one-time thing either. I do this continuously to ensure
  </p>

  <ul>
  <li>all assumptions are still valid,</li>
  <li>the current end goal is still the same, and</li>
  <li>the current path is the most efficient.</li>
  </ul>

  <p>
    The hardest thing is realizing you are overwhelmed. Managing your tasking is the easier half of the problem. Write down your tasks. Document your problems, solutions and decisions. This will serve as a reference for yourself, co-workers and new hires. Build a consensus with your team when you encounter something that takes more time than expected. Agree that a problem exists and needs to be solved. Dedicate time to solving the problem unencombered by the next task or the amount of tasks ahead of you.
  </p>

  <p>
    These are just a few ways you can be intentional with your work and address each task with focus. Work doesn't have to be stressful. But when it is, keep in mind, work doesn't end. There will always be more tasks. I like the old cliché "The journey is important, not the destination." This helps me go home for the day even if there is more I could do.
  </p>

  <hr>

  <h3>Why is space black?</h3>
  <div class="subhead">2020-04-21</div>

  <p>
    It dawned on me once that this doesn't make intuitive sense. If we have a sun and there are many suns, potentially an uncountable amount, and there is nothing diminishing light from those suns to Earth, why is space so dark? This is not a new question, but this (probably short) article is mostly to keep a record of what I could find as an answer in my own words.
  </p>

  <img src="guillermo-ferla-M_EgSITHrKA-unsplash.jpg" alt="Photo by Guillermo Ferla on Unsplash" class="center"/>
  <div class="caption">Photo by Guillermo Ferla on Unsplash</div>

  <p>
    Olbers' paradox is a description of this very observation. Being a paradox, it afforded me the comfort that I am not alone in not knowing everything. The initial assumptions and question are the same as my own, that the night sky would indeed be filled with the light from the all of the stars. The caveat is this would be true if the universe was static, meaning stars and planets were not in constant motion.
  </p>

  <p>
    Before talking about why the motion of the universe is important, we need to understand the properties of light and its transmission. Visible light is an electromagnetic wave transmitting within a specific frequency range. Within this specific range, the frequency can determine what color the light is.
  </p>

  <p>
    The graphic below shows the electromagnetic spectrum wavelengths between 380 nm and 750 nm (790 THz and 405 THz respectively). Light waves with frequencies outside this range are not visible, thus appear black.
  </p>

  <img src="Linear_visible_spectrum.svg" alt="Graphic by Wikipedia user Gringer" width=100%/>
  <div class="subhead">Graphic by Wikipedia user Gringer</div>

  <p>
    Stars produce light within the visible spectrum, like our sun. Back to Olber's paradox, using our understanding of the universe, stars and planets are in constant motion, which also means the distance between stars and planets are changing. This does not include all stars as some may be moving in parallel or be changing in distance very slowly.
  </p>

  <p>
    This constant change in distance causes the light produced from stars to change in frequency relative to planets that would observe that light (e.g. Earth), similar to doppler where sound waves change as an ambulance goes by you on the street. This phenomenon is known as redshift. The term "redshift" refers to the longest wavelengths of visible light being red, and as light wavelengths get longer, they "shift" towards red. The opposite is known as "blueshift".
  </p>

  <p>
    Knowing these things, we can see how many of the stars moving relative to Earth, produce light that will be shifted outside of the visible light frequency range. This still allows for the stars we can see, whose relative distances' aren't changing fast enough to shift the electromagnetic waves outside the visible spectrum.
  </p>

  <p>
    This particular observation is actually used to support the Big Band theory. For me it also reminds me that I still don't know everything and probably never will. But that's alright because figuring things out is what its all about (re-read in sing-song voice).
  </p>

  <h3>Exceptions</h3>
  <div class="subhead">2020-04-14</div>

  <p>
    Exceptions can be a very useful mechanism for writing less code while providing context for what went wrong. There are probably tall epics written describing how exceptions <i>should</i> be used, whether they should be used for flow control or not for example. I won't pretend to be a well-versed C++ philosopher, but I will describe one way that I think is effective, efficient and simple. It doesn't need to be complicated. Below is a typical use case for a C++ class wrapping a POSIX interface.
  </p>

  <pre>
void* FileReader::Read(const int fd, const int buffer_size) {
    uint8_t* buffer = new uint8_t[buffer_size];
    ssize_t rc = read(fd, buffer, buffer_size);
    if (rc != 0) {
        // Handle error
    }
    return buffer;
}</pre>

  <p>
    There are many ways to skin this cat. You could log an error and return nullptr. This would mean users of this function need to check the result returned for nullptr and handle it appropriately. In this context, this would defeat the purpose of the function. Half the function is handling the error. This is similar to returning an error code, without the context of what went wrong. Hopefully that is solved by logging in the function.
  </p>

  <p>
    If your on a system that can run Linux, likely you can handle throwing exceptions. Exceptions were invented to solve the problem described above. Regardless of the interface, errors are handled completely independent of normal program operation. I believe this is a better interface to use over returning error codes or reserving special values (e.g. nullptr for pointers) to indicate an error occurred.
  </p>

  <p>
    Assuming we've chosen to go with throwing errors versus returning error codes, we have to choose what type to throw. The C++20 standard defines almost 30 exception types to choose from. I believe it is usually better to use your own exception types rather than using exception types defined in the standard library. This will aide in reducing confusion for users or maintainers by differentiating the origin points of the error.
  </p>

  <p>
    As programmers, it is natural to wrap a layer of abstraction around specific code and concepts for the sake of reusability. Here, when I suggest using your own exception types, it seems natural to set up an entire slew of exception types, each defining a specific type of error that occurs so each one can be handled properly. I can sense the readers who have stopped reading and have already whipped out their editors to start writing a beautifully reusable system of exception definitions (see Poco's <tt><a href="https://github.com/pocoproject/poco/blob/master/Foundation/include/Poco/Exception.h#L157">POCO_DECLARE_EXCEPTION</a></tt>).
  </p>

  <p>
    I suggest doing this on a much smaller scale. Define one exception for your namespace, inherit from <tt>std::exception</tt>, and use this everywhere. Only define a custom exception when you actually need to handle resource clean up. When throwing, dynamic resources are not freed, but I would argue if you are throwing due to an exceptional circumstances let it get caught in main and exit in the default case. I've found this to be the 80% solution. Typical resources like memory and file handles will be released upon exit.
  </p>

  <p>
    And that's it. There are reasons you would want custom exceptions, to communicate specific information to the user of your code that something wrong and there is something they can do about it during runtime. They can catch these specific errors and programmatically deal with the errors. In my experience this situation happens <i>much less</i> often than just knowing what went wrong by logging a string and terminating the program.
  </p>

  <h3>Adventures in SPI</h3>
  <div class="subhead">2019-12-19</div>
  <p>
    Serial peripheral interface (SPI) is a wonderful protocol. It has a simple way to serially transfer data in and out of multiple devices using one or more chip select lines, master-out/slave-in (MOSI) and master-in/slave-out (MISO) lines. You can use chip select lines for sending data in and out of various devices. The problem lies when your clock line doesn't clock. It's an even bigger problem when none of your voltages change when they are supposed to.
  </p>

  <p>
    The first step to realize everything is broken is first to get it working on a different system. Our system had a microcontroller, a couple of chips that spoke SPI and a uFPGA. The SPI lines were intended for the two chips, they were not going to be used for the uFPGA unless needed for an unforeseen reason. At the point in our development we wanted to talk to one of the chips, so we bought an evaluation board for the microcontroller and the chip we were currently targeting.
  </p>

  <p>
    With said evaluation boards, power supplies, cables, bread board, logic analyzer, and related software installed a suitable system was put together to develop the necessary software to configure the chip. Data sheets were poured over, software was developed and things were found to be working... on the development set up.
  </p>

  <p>
    After this, the software was loaded onto a custom hardware platform for testing. We we're very hopeful and instantly failed. The logic analyzer showed a vast wasteland of fixed voltages. After many rabbit holes were thoroughly explored, we settled on validating the lines were physically connected and could be driven correctly. This felt like a bad place to be in. To do this, we first targeted the SCLK line. We loaded the microcontroller with an image that put the SCLK into GPIO mode and started manually clocking. What we found was an attempt at clocking, but the voltages were not reaching their expected limits of 0 volts and 3.3 volts. Instead it was clocking between 0 and ~1.5 volts.
  </p>

  <p>
    This led us to believe another device was attempting to drive the line. A uFPGA that was using the SPI line, had some debug values set for those particular pins for the eval board and needed to be marked input. With this dealt with, manual clocking of the SPI clock was working wonderfully, driving the lines to the 3.3 and 0 volts limits. With our problem solved, we removed the custom MCU software and replaced it with the current production software. Once we applied the appropriate patch to the uFPGA software and loaded the working development code, we very let down to find that none of the SPI lines even toggled. The hunt for functionality continued.
  </p>

  <p>
    When initializing the SPI driver it correctly held SCLK high as required for our system but when data was written to the data output register, SCLK did not move. In fact no lines transitioned at all. This led to more rabbit holes to investigate for why these lines did not move. To make a longer story somewhat shorter, we found a multi-master SPI select pin on the microcontroller tied to ground instead of 3.3 volts. Multi-master is a great thing, but not when you don't correctly account for it. Having it wired this way caused all SPI operations to cease regardless of any software we could load, since the built in SPI peripheral was operating in a slave mode. A minor hardware change was required, but once in place, we filled in our rabbit holes and finally had SPI working.
  </p>

  <p>
    The main take away for me from this problem is to carefully approach the software design of custom hardware by first understanding each pin on the chip and how it fits into the overall design. This seems like a simple thing, but can be forgotten in the fray of functional requirements and deadlines. Better developers than I have started their design with a list of each possible pin, their location on the development and production hardware, and their desired initial state. I know because I've used those pin tables many times on the same project.
  </p>

  <h3>Hello, World!</h3>
  <div class="subhead">2019-12-18</div>
  <p>
    Hello, World! This is an attempt to create some content to get a small simple website started. This is intended as an exercise for me to learn how to program a webpage. I am not a writer in any capacity, so bear with me as I learn how to write while I attempt it at the same time. Hopefully I'll have some interesting content to read someday. In the meantime here's a program, its definitely not intended just for me to figure out how preformatted text works...
  </p>

  <p>
    <pre>
#include &lt;iostream&gt;

using namespace std;

int main(int argc, char* argv[]) {
  cout << "Hello, World!" << endl;
  return 0;
}</pre>
  </p>

  <hr>

  <footer>
    <a href="https://twitter.com/danielrayali">twitter</a>
    <a href="https://github.com/danielrayali">github</a>
    <p>© <script>document.write(new Date().getFullYear())</script> Daniel Ali</p>
  </footer>

  </body>
</html>
