<!DOCTYPE html>
<html lang="en-US">

  <head>
    <title>Daniel Ali</title>
    <meta charset="UTF-8">
    <style>
      h1 {
        display:block;
        font-size: 2em;
        margin-block-start: 0.67em;
        margin-block-end: 0.67em;
        margin-inline-start: 0px;
        margin-inline-end: 0px;
        font-weight: bold;
        margin-bottom: 0px
      }
      h3 {
        display: block;
        font-size: 1.17em;
        font-style: normal;
        margin-block-start: 1em;
        margin-block-end: 1em;
        margin-inline-start: 0px;
        margin-inline-end: 0px;
        font-weight: bold;
        margin-bottom: 0px
      }
      pre {
        background-color: #edf5e1;
        font-family: 'Courier New', Courier, monospace;
        color: #0d1432;
        padding: 10px;
      }
      pre.inline {
        background-color: unset;
        padding: unset;
      }
      p {
        text-align: left;
        line-height: 1.6;
      }
      body {
        width:50%;
        margin:auto;
        background-color: #eee2dc;
      }
      .subhead {
        font-style:italic;
        padding-top:2px;
        margin-top:0px;
        font-size:small;
      }
      /* Create two equal columns that floats next to each other */
      .column {
        width: 50%;
      }
      .left {
        float: left;
      }
      .right {
        float: right;
        height: 78.44px;  /* This is probably not the right way to do this */
        margin-bottom: 0px;
      }
      #right-content {
        margin-top: 55px;
        margin-bottom: 0px;
        float: right;
      }
      /* Clear floats after the columns */
      .row:after {
        content: "";
        display: table;
        clear: both;
      }
    </style>
  </head>

  <body style="font-family: Verdana,sans-serif;">
  <header>
    <div class="row">
      <div class="column left">
        <h1>Daniel Ali</h1>
        <div class="subhead">On software and things</div>
      </div>
      <div class="column right">
        <p id="right-content"><a href="index.html">home</a> <a href="about-me.html">about me</a></p>
      </div>
    </div>
  </header>

  <hr>

  <h3>Exceptions</h3>
  <div class="subhead">2020-04-14</div>

  <p>
    Exceptions can be a very useful mechanism for writing less code while providing context for what went wrong. There are probably tall epics written describing how exceptions <i>should</i> be used, whether they should be used for flow control or not for example. I won't pretend to be a well-versed C++ philosopher, but I will describe one way that I think is effective, efficient and simple. It doesn't need to be complicated. Below is a typical use case for a C++ class wrapping a POSIX interface.
  </p>

  <pre>
void* FileReader::Read(const int fd, const int buffer_size) {
    uint8_t* buffer = new uint8_t[buffer_size];
    ssize_t rc = read(fd, buffer, buffer_size);
    if (rc != 0) {
        // Handle error
    }
    return buffer;
}</pre>

  <p>
    There are many ways to skin this cat. You could log an error and return nullptr. This would mean users of this function need to check the result returned for nullptr and handle it appropriately. In this context, this would defeat the purpose of the function. Half the function is handling the error. This is similar to returning an error code, without the context of what went wrong. Hopefully that is solved by logging in the function.
  </p>

  <p>
    If your on a system that can run Linux, likely you can handle throwing exceptions. Exceptions were invented to solve the problem described above. Regardless of the interface, errors are handled completely independent of normal program operation. I believe this is a better interface to use over returning error codes or reserving special values (e.g. nullptr for pointers) to indicate an error occurred.
  </p>

  <p>
    Assuming we've chosen to go with throwing errors versus returning error codes, we have to choose what type to throw. The C++20 standard defines almost 30 exception types to choose from. I believe it is usually better to use your own exception types rather than using exception types defined in the standard library. This will aide in reducing confusion for users or maintainers by differentiating the origin points of the error.
  </p>

  <p>
    As programmers, it is natural to wrap a layer of abstraction around specific code and concepts for the sake of reusability. Here, when I suggest using your own exception types, it seems natural to set up an entire slew of exception types, each defining a specific type of error that occurs so each one can be handled properly. I can sense the readers who have stopped reading and have already whipped out their editors to start writing a beautifully reusable system of exception definitions (see Poco's <tt><a href="https://github.com/pocoproject/poco/blob/master/Foundation/include/Poco/Exception.h#L157">POCO_DECLARE_EXCEPTION</a></tt>).
  </p>

  <p>
    I suggest doing this on a much smaller scale. Define one exception for your namespace, inherit from <tt>std::exception</tt>, and use this everywhere. Only define a custom exception when you actually need to handle resource clean up. When throwing, dynamic resources are not freed, but I would argue if you are throwing due to an exceptional circumstances let it get caught in main and exit in the default case. I've found this to be the 80% solution. Typical resources like memory and file handles will be released upon exit.
  </p>

  <p>
    And that's it. There are reasons you would want custom exceptions, to communicate specific information to the user of your code that something wrong and there is something they can do about it during runtime. They can catch these specific errors and programmatically deal with the errors. In my experience this situation happens <i>much less</i> often than just knowing what went wrong by logging a string and terminating the program.
  </p>

  <h3>Adventures in SPI</h3>
  <div class="subhead">2019-12-19</div>
  <p>
    Serial peripheral interface (SPI) is a wonderful protocol. It has a simple way to serially transfer data in and out of multiple devices using one or more chip select lines, master-out/slave-in (MOSI) and master-in/slave-out (MISO) lines. You can use chip select lines for sending data in and out of various devices. The problem lies when your clock line doesn't clock. It's an even bigger problem when none of your voltages change when they are supposed to.
  </p>

  <p>
    The first step to realize everything is broken is first to get it working on a different system. Our system had a microcontroller, a couple of chips that spoke SPI and a uFPGA. The SPI lines were intended for the two chips, they were not going to be used for the uFPGA unless needed for an unforeseen reason. At the point in our development we wanted to talk to one of the chips, so we bought an evaluation board for the microcontroller and the chip we were currently targeting.
  </p>

  <p>
    With said evaluation boards, power supplies, cables, bread board, logic analyzer, and related software installed a suitable system was put together to develop the necessary software to configure the chip. Data sheets were poured over, software was developed and things were found to be working... on the development set up.
  </p>

  <p>
    After this, the software was loaded onto a custom hardware platform for testing. We we're very hopeful and instantly failed. The logic analyzer showed a vast wasteland of fixed voltages. After many rabbit holes were thoroughly explored, we settled on validating the lines were physically connected and could be driven correctly. This felt like a bad place to be in. To do this, we first targeted the SCLK line. We loaded the microcontroller with an image that put the SCLK into GPIO mode and started manually clocking. What we found was an attempt at clocking, but the voltages were not reaching their expected limits of 0 volts and 3.3 volts. Instead it was clocking between 0 and ~1.5 volts.
  </p>

  <p>
    This led us to believe another device was attempting to drive the line. A uFPGA that was using the SPI line, had some debug values set for those particular pins for the eval board and needed to be marked input. With this dealt with, manual clocking of the SPI clock was working wonderfully, driving the lines to the 3.3 and 0 volts limits. With our problem solved, we removed the custom MCU software and replaced it with the current production software. Once we applied the appropriate patch to the uFPGA software and loaded the working development code, we very let down to find that none of the SPI lines even toggled. The hunt for functionality continued.
  </p>

  <p>
    When initializing the SPI driver it correctly held SCLK high as required for our system but when data was written to the data output register, SCLK did not move. In fact no lines transitioned at all. This led to more rabbit holes to investigate for why these lines did not move. To make a longer story somewhat shorter, we found a multi-master SPI select pin on the microcontroller tied to ground instead of 3.3 volts. Multi-master is a great thing, but not when you don't correctly account for it. Having it wired this way caused all SPI operations to cease regardless of any software we could load, since the built in SPI peripheral was operating in a slave mode. A minor hardware change was required, but once in place, we filled in our rabbit holes and finally had SPI working.
  </p>

  <p>
    The main take away for me from this problem is to carefully approach the software design of custom hardware by first understanding each pin on the chip and how it fits into the overall design. This seems like a simple thing, but can be forgotten in the fray of functional requirements and deadlines. Better developers than I have started their design with a list of each possible pin, their location on the development and production hardware, and their desired initial state. I know because I've used those pin tables many times on the same project.
  </p>

  <h3>Hello, World!</h3>
  <div class="subhead">2019-12-18</div>
  <p>
    Hello, World! This is an attempt to create some content to get a small simple website started. This is intended as an exercise for me to learn how to program a webpage. I am not a writer in any capacity, so bear with me as I learn how to write while I attempt it at the same time. Hopefully I'll have some interesting content to read someday. In the meantime here's a program, its definitely not intended just for me to figure out how preformatted text works...
  </p>

  <p>
    <pre>
#include &lt;iostream&gt;

using namespace std;

int main(int argc, char* argv[]) {
  cout << "Hello, World!" << endl;
  return 0;
}</pre>
  </p>

  <hr>

  <footer>
    <a href="https://twitter.com/danielrayali">twitter</a>
    <a href="https://github.com/danielrayali">github</a>
    <p>Â© 2020 Daniel Ali</p>
  </footer>

  </body>
</html>
